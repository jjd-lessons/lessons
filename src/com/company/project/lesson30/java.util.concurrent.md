# Пакет java.util.concurrent
Данный пакет включает в себя набор классов, которые ориентированы на работу с несколькими потоками.

Функционально пакет можно разделить на несколько частей:
1. коллекции и мапы для работы с многопоточных средах
2. очереди (в том числе блокирующие)
3. утилиты для синхронизации потоков: Exchanger, Phaser, CyclicBarrier, CountDownLatch, Semaphore
4. классы для создания пулов потоков
5. альтернативные механизмы синхронизации (замена synchronized, wait, notify, notifyAll)
6. классы с поддержкой атомарных операций над примитивами и ссылками

Замена synchronized - тип данных Lock
1) ReentrantLock
2) ReadWriteLock: операции записи эксклюзивны, операции чтения доступны нескольким потокам

Методы ReentrantLock: 
1. `lock()` - блокировка ресурса
2. `unlock()` - освобождение ресурса
3. `tryLock()` - ожидание ресурса на протяжении определенного времени
4. `newCondition()` - для создания альтернативы методам wait и notify
5. `isLocked()` - позволяет узнать, заблокирован ли ресурс
6. `getQueueLength()` - позволяет узнать, сколько потоков ожидает ресурс
7. https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html

Методы ReadWriteLock:
1. `lock()` - блокировка ресурса
2. `unlock()` - освобождение ресурса
3. `tryLock()` - ожидание ресурса на протяжении определенного времени
4. `newCondition()` - для создания альтернативы методам wait и notify
5. `readLock()` - блокировка ресурса для чтения
6. `writeLock()` - блокировка ресурса для записи
7. https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/ReadWriteLock.html

#### Коллекции и мапы
1. допускают одновременное чтение и внесение изменений разными потоками
2. не вызывают исключение ConcurrentModificationException при удалении в цикле
3. коллекции предоставляют метод addIfAbsent(obj), который позволяет добавить элемент, в случае отсутствия данной записи, причем сделать это атомарно.
4. мапы предоставляют метод putIfAbsent(key, value), который позволяет добавить в Map ключ-значение, в случае отсутствия данной записи, причем сделать это атомарно.

CopyOnWriteArrayList, CopyOnWriteArraySet используют алгоритм CopyOnWrite,
что предполагает создание копии внутреннего массива на каждое изменение коллекции (add, set, remove).

ConcurrentSkipListSet хранит элементы в отсортированном виде, использует алгоритм SkipList - набор связных списков

ConcurrentHashMap использует несколько (по умолчанию 16) сегментов, каждый сегмент представляет собой HashMap.
При работе с данной мапой сначала определяется сегмент, в который необходимо добавить/удалить/изменить пару ключ-значение,
после чего данный сегмент блокируется, остальные сегменты остаются доступны.

ConcurrentNavigableMap обеспечивает возможность получения элементов отображения относительно других элементов (наименьший/наибольший ключ, первый/последний элементы и тд)

ConcurrentSkipListMap хранит элементы в отсортированном по ключам порядке, использует алгоритм SkipList - набор связных списков

#### Очереди (в том числе блокирующие)

Блокирующие очереди используются, если необходимо приостановить работу потока, если не соблюдены определенные условия, например, очередь переполнена,
в очереди нет элементов и тп
1. реализуют интерфейсы BlockingQueue, BlockingDeque, TransferQueue.
2. реализация BlockingQueue гарантирует, что любая попытка извлечь элемент (метод take) из пустой очереди заблокирует вызывающий поток до тех пор,
   пока не появится доступный элемент, а любая попытка вставить элемент (метод put) в заполненную очередь заблокирует вызывающий поток до тех пор,
   пока не освободится место для нового элемента.
3. реализация интерфейса TransferQueue позволяет при добавлении элемента в очередь заблокировать вставляющий поток до тех пор,
   пока другой поток не заберет элемент из очереди.

ArrayBlockingQueue реализует кольцевой буфер. Параметр fair в конструкторе позволяет управлять соблюдением очередности ожидающих и извлекающих потоков.
Размер очереди задается в конструкторе и не меняется.

SynchronousQueue - очередь, в которой каждая операция добавления 
должна ждать соответствующей операции удаления в другом потоке и наоборот (принцип «один вошел, один вышел»).

LinkedTransferQueue позволяет при добавлении элемента в очередь (метод transfer) заблокировать вставляющий поток до тех пор, пока другой поток не заберет элемент из очереди.
Дает гарантию, что элемент будет получен из очереди. Размер очереди можно задать в конструкторе, по умолчанию - максимальный int

DelayQueue позволяет извлекать элементы только после некоторой задержки, определенной в каждом элементе, те позволяет выполнять задачи по расписанию.

LinkedBlockingQueue (более высокую производительность и более высокий расход памяти) - очередь на связанных узлах.

LinkedBlockingDeque — двунаправленная блокирующая очередь на связанных узлах.
