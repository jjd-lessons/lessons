Stack память у каждого потока своя, но heap память - общая. Если есть потоки, которые обращаются к общим ресурсам
для записи (изменения свойств объекта), то работу потоков нужно синхронизировать. Если этого не сделать, потоки могут
войти в состояние гонки, когда несколько потоков могут одновременно считывать данные из переменной и записывать в нее:

1. Использовать synchronized блок.
2. Использовать synchronized метод.
3. Использовать возможности пакета java.util.concurrent.*.

## synchronized блок и synchronized метод:

         // блок
         synchronized(объект, но не примитив) {             
            пока инструкции блока выполняются, права на мониор указанного объекта принадлежат текущему потоку,
            другие потоку переходят в состояние blocked и ждут освобожения прав          
         }
         // метод
         synchronized public void action() {             
            пока инструкции метода выполняются, права на мониор объекта, у которого вызван метод,
            принадлежат текущему потоку, другие потоку переходят в состояние blocked и ждут освобожения прав          
         }

Каждый объект имеет ассоциированный с ним монитор (он используется для управления доступом к объекту). Нельзя
указать, в какой последовательности потоки будут захватывать монитор объекта.

При использовании синхронизации, в synchronized блок или synchronized метод необходимо помещать только необходимы
инструкции. Инструкции, не связанные с изменениями свойств объекта, на котором происходит синхронизация, должны
выноситься за пределы блока или метода.

Бывают ситуации, когда правильно будет использовать несколько synchronized блоков для изменения отдельных свойств
объекта, чтобы дать возможность другим потокам работать с общим ресурсом.

Необходимо быть осторожными при синхронизации ресурсов, хранящихся по принципу пула строк.

Проблемы, возникающие в борьбе потоков за ресурсы:

1. Deadlock (взаимная блокировка потоков) - ситуация, когда 2 и более потока блокируются, бесконечно ожидая друг друга.
2. Starvation (голодание) - ситуация, когда поток не может получить регулярный доступ к общим ресурсам, не может
   добиться прогресса. Это происходит, когда общие ресурсы становятся недоступными в течение длительного времени из-за "
   жадных" потоков. Например, если один поток часто вызывает синхронизированный метод, другие потоки, которым также требуется
   синхронизированный доступ к одному и тому же объекту, часто будут блокироваться.
3. Livelock - ситуация, когда поток часто действует в ответ на действие другого потока, а действие другого потока
   также является ответом на действие третьего и так далее. Потоки не заблокированы, но и не прогрессируют, так
   постоянно ожидают
   действий друг друга.


## Методы класса Object для работы с многопоточностью:

Методы `void wait() / void  wait(long mls) / void notify() / void notifyAll()` можно вызвать только в `synchronized`
блоке или `synchronized` методе.

### Описание методов:

1. `void wait()` - приостанавливает работу текущего потока до тех пор, пока тот не будет разбужен notify методами из
   другого потока;
2. `void  wait(long mls)` - приостанавливает работу текущего потока до тех пор, пока тот не будет разбужен notify
   методами из другого потока или пока не пройдет указанное количество mls

Потоки, приостановленные методами `wait()` и `wait(long mls)` могут проснуться без каких либо на то причин.

3. `void notify()` - возобновляет работу случайного потока, который был приостановлен wait методами. Нельзя указать,
   какой именно поток должен возобновить работу. Нельзя указать очередность пробуждения потоков.
4. `void notifyAll()` - возобновляет работу всех потоков, которые были приостановлены wait методами.

Методы `notify()` и `notifyAll()` не пробуждают потоки, которые приостановлены методом sleep.